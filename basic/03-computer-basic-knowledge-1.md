# 计算机基本知识概览

作者：000lbh
许可协议：CC BY-NC-SA

## 软件与硬件

什么是软件？什么是硬件？相信刚接触计算机的同学也不会不清楚这个问题，我们在这里并不打算给软件和硬件一个正式的定义，而是通过举例介绍各种软件和硬件，从而使得同学们获得一个直观的认识。

### 硬件

各位刚刚接触计算机的同学可能还没有来得及拆开过你心爱的计算机。没关系，我们为大家提供了一些图片，同时通过这些图片进行介绍。

#### 冯诺依曼架构

冯诺依曼提出了一种计算机架构，由运算器、控制器、存储器、输入输出设备组成，不区分代码和数据。现代计算机基本都基于这个架构进行设计。

![Von Neumann Architecture](/assets/basic/03-computer-basic-knowledge-1/Von_Neumann_Architecture.svg)

#### CPU

CPU 是整个计算机的核心，具有运算和控制的功能。CPU 从存储设备中读取代码和数据，尽管现代处理器对代码和数据会有不同的处理，但是其本质上并没有严格的区分。代码由一条一条的指令组成，CPU 按照顺序一条一条执行从存储设备中读取的指令（至少让软件和程序员看到的必须是这样），指令可以是修改 CPU 的状态，进行运算，或者是从其他硬件读取信息或者输出信息。

![Intel 8086](/assets/basic/03-computer-basic-knowledge-1/Intel_C8086.jpg)

图 1. 这是 Intel 8086 处理器，和现在的处理器“长相”很不一样，但是你案头的计算机用的处理器很可能与之兼容（除非你是新版 Apple 或者你自己知道你用的不是 x86 架构的处理器）。图源自 wiki，获 CC BY-SA 授权

目前市面上的处理器拥有很多种不同的 ISA(Instruction Set Architecture)，ISA 定义了处理器有哪些指令、指令编码方式和功能、怎么寻找和读取数据、能暂存多少数据、每个暂存的数据有多大、数据存放的顺序如何等等内容，并不是指令的简单集合。一般来说，为其他 ISA 编译好的程序是不能够直接在当前 ISA 上运行的，需要转译，或者（在有源代码的情况下）重新按照当前 ISA 进行编译。同学们在下载软件时，也要注意 ISA 的信息。下面是一些常见的 ISA：

- x86: 最经典最常见的 ISA，同学案头计算机的处理器基本都基于此，历史兼容性好（换句话说就是历史包袱重）
- ARM: 移动端（包括手机）常见的 ISA，不管是苹果还是遥遥领先，处理器都使用该 ISA。苹果 M 系列计算机也使用该处理器
- RiscV: 新兴的开源 ISA，嵌入式设备中有使用，学校也喜欢用于教学
- Loongarch: 国产 ISA
- 还有其他诸如 MIPS、PowerPC 等架构不再赘述

现代的 ISA 一般都设计保护功能。保护功能提供不同的模式，在特权模式下，代码有对处理器和硬件的（几乎）完全的控制权；而在非特权模式（用户模式）下，代码只能控制有限的资源，进行“安全”的操作，而其他操作需要通过切换到特权模式完成。同时，ISA 提供了虚拟内存的功能，也就是将物理内存地址（也就是前文提到的“存储空间的编号”）映射到虚拟地址，并设置访问权限。

> 历史的注记：Intel 当年开发了一个全新的 64 位架构，IA64，该架构具有很多让人眼前一亮的特性，然而与之前 Intel 的 x86 完全不兼容。后来 AMD 开发了与之前 x86 架构兼容的 AMD64 架构，迅速抢占市场份额，Intel 后来慢慢放弃了 IA64 架构，转而采用 AMD64 架构，或者更中立的名称，x86-64 架构。

#### 内存

这里说的内存是 RAM，断电丢失数据的随机存储器。然而在不同语境下，内存也可以指下文中的“硬盘”，请注意区分。

内存是处理器 CPU 能够直接访问到的数据存储器。内存被划分为一个个存储单元，每个存储单元大小一个字节，或者说 8 比特，也就是 8 个数字 0 或者 1，每个存储单元都有唯一编号。CPU 通过存储单元的编号拿出存储单元中的数据或者向存储单元写入数据。随机存储器的“随机”意思是不论拿什么编号来找数据，所需时间总是差不多的。

内存访问速度比其他外部存储要快，但是随着处理器的发展，内存速度的提升却跟不上处理器速度提升的步伐。从内存中找一个数据所需的典型时间大概够处理器执行几十甚至上百条指令，因此缓存被放入了处理器内部。关于这一点，我们将在本章节第二部分讲述。

现在大家可以把内存理解成一个大数组（实际上也差不多），数组的每个元素都是一个字节，每个元素都有一个编号，CPU 可以通过编号找到对应的元素。

#### 硬盘

有时候也被称作“内存”或者“外存”（是不是有些混乱？），不过你只需要记住我们这里讲的是断电数据不丢失的可以反复改写的存储设备即可。目前市面上主要有两种硬盘，一种是机械硬盘 HDD，里面有一组镜子一样的盘片，旁边有一个磁头。机械硬盘工作时，盘片高速运转，磁头读写其中的内容；另一种是固态硬盘 SSD，里面没有高速运转的机械结构，取而代之的是储存芯片和控制电路。固态硬盘具有较为明确的寿命特点，其写入次数有限，且长时间不通电时不能保证数据稳定（以年为单位计算）。为了最大化固态硬盘寿命，其一般有较为复杂的控制电路，保证写入均匀地发生在固态硬盘的不同部位。一般来说，固态硬盘较贵，速度较快，长时间存放稳定性较差，但是个人日常使用的实际寿命并不一定比机械硬盘差。总之，重要数据应该做好备份。

![HDD](/assets/basic/03-computer-basic-knowledge-1/Laptop-hard-drive-exposed.jpg)
图 2. 机械硬盘内部结构。图源自 wiki，获 CC BY-SA 授权

> 提示：如果你在比较早的时候接触过或者从长辈口中听说过“磁盘碎片”这回事，请注意，固态硬盘不要整理磁盘碎片。

#### 其他存储设备

- 光盘：以前常见的存储设备，一般只能写入一次，存储容量在几百 M 到几十 G 不等。
- 软盘：更古董的设备，存储容量在几个 M 左右。
- 磁带：顺序存储器，意味着找数据的时间和当前读写位置的距离成正比（而不像随机存储器，基本无关），用于长时间保存大量数据，需要特定的仪器和环境。

#### 存储层次结构

存储器有很多种类，速度、容量单价、稳定性都各有不同。根据其响应速度，存储器可被划分为多级结构：

![Memory Hierarchy](/assets/basic/03-computer-basic-knowledge-1/ComputerMemoryHierarchy.svg)
图 3. 存储器层次结构示意图，公有领域作品

处理器中的寄存器，通常用于存储计算中的临时数据，速度要求极高，单位容量价格自然也是十分高。在寄存器和内存中间，一般还存在多级缓存，缓存对一般程序员不可见。常用的数据将被放入速度快很多的缓存中。缓存单位容量的价格也比较高，目前个人计算机缓存的容量普遍在数十 MB 以内。内存先前已经介绍过了，在此不再赘述。

以上三种存储都属于易失性存储（volatile），也就是断电后数据将会在短时间内消失。前两种存储是静态随机存储，意味着在通电状态下其状态可保持，制造所需晶体管较多，而后者是动态随机存储，即使通电，数据也会随时间流逝而消失，需要每几个毫秒去刷新全部存储单元。

> 你可能会想问，缓存为什么能够在程序员不参与的情况下完成内存访问的提速，这就涉及到一个重要的概念：局部性原理。这个原理主要说的是，一个程序在总是倾向于访问最近访问过的存储单元或者与之相邻的存储单元，缓存可以据此将最近访问过的存储单元放入自身当中，或者预测将要访问的存储单元，将其提前放入自身当中。当然这种预测并不会百发百中，而基于缓存的工作原理，提升自己程序的局部性，是改善程序性能的一个好方法。

#### GPU

也叫做显卡，大量并行处理，最开始用于图形处理，目前也可用于 AI，科学计算等等。一般来说，GPU 的计算能力远远大于 CPU，但是单核处理能力还是 CPU 更强，GPU 则以核数和专为并行设计的独特的架构取胜。

#### 主板

将各种硬件连接在一起，方便更换、扩展，提供固件进行硬件自我检查和系统初始化，保存各个硬件的配置等。

#### 电源

为各种硬件供电。大部分硬件需要 5 V 以内的直流供电，而一般家庭供电是 220 V, 50 Hz 交流，因此需要此模块。

#### 计算机的发展历程

1945 年（1946 年 2 月 14 日对外公布），第一台计算机 ENIAC 诞生了。

### 软件

软件根据其功能不同也可以分为很多种，有一些软件是直接跟硬件打交道的，而另一些软件则直接跟用户打交道，中间还有连接两者的桥梁。他们分别是操作系统和硬件驱动程序，应用程序，和“库”。操作系统提供了对各种资源，比如处理器、内存、网络、各种外部设备如打印机等的统一抽象，使得大部分应用程序在大部分不同的硬件上都能正确运行，简化了应用程序员的工作，同时也将不同资源进行隔离，尽可能防止有缺陷或者恶意的程序影响其他程序运行。

这一节我们着重介绍 Windows 操作系统和 Linux 操作系统。

#### Windows

Windows 是微软公司开发的图形化操作系统，具有成熟的图形界面。同学们个人计算机日常使用的系统很可能就是 Windows（苹果用户除外）。Windows 系统较为庞大，里面很多组件在日常使用中完全用不到，甚至是以一种历史包袱的形式存在。不过正因为如此，很多老旧的将近 20 年前的 Windows 软件仍然能在最新的系统中正常运行。

#### Linux

从 1991 年 Linus 宣告 Linux 的存在，到 2024 年，Linux 已经走过 30 多个年头。下面是 Linus 向社区宣告 Linux 存在的邮件（尽管当时还没有名字）：
```
Hello everybody out there using minix -

I'm doing a (free) operating system (just a hobby, won't be big and
professional like gnu) for 386(486) AT clones. This has been brewing
since april, and is starting to get ready. I'd like any feedback on
things people like/dislike in minix, as my OS resembles it somewhat
(same physical layout of the file-system (due to practical reasons)
among other things).

I've currently ported bash(1.08) and gcc(1.40), and things seem to work.
This implies that I'll get something practical within a few months, and
I'd like to know what features most people would want. Any suggestions
are welcome, but I won't promise I'll implement them :-)

Linus (torv...@kruuna.helsinki.fi)

PS. Yes - it's free of any minix code, and it has a multi-threaded fs.
It is NOT protable (uses 386 task switching etc), and it probably never
will support anything other than AT-harddisks, as that's all I have :-(. 
```

严格来说，Linux 只是一个“操作系统内核”，并没有包含用户态的程序，而一般来说，一个完整的操作系统需要包含用户态的一些基础设施，比如供更上层应用程序使用的库函数，以及用于管理其他软件和硬件，但不必放进内核态的程序。目前说 Linux 操作系统，一般指的是基于 Linux 内核衍生的各大发行版。各种 Linux 发行版为 Linux 内核配置了一系列用户态程序，这样才能构成一个完整的操作系统。

与 Windows 内核（名字是 NT 内核）不同，Linux 内核并不直接提供图形界面，只提供了不同的视频模式，Linux 发行版的图形界面属于用户态程序，且是选配的，对于一个不需要图形界面的服务器，完全可以省下这一笔空间。与 Windows 不同，在 Linux 发行版中，Linux 内核和系统的其他组建完全都是由一个个软件包组成的，如果你不需要某个功能，完全可以将相应的软件包移除。也可以用其他功能类似的软件包替换某个软件包。系统具有高度可定制性。

Linux 是一种类 Unix 操作系统，API 符合 POSIX 标准。

还有一个更大的不同，就是 Linux 属于自由软件，和 Linux 内核一道组成发行版的程序绝大部分也是自由软件。自由软件的源代码不仅公开，还需要能够自由传播、修改、销售，只要你遵守许可证的条件。常见的许可证包括 GPL，这个许可证要求基于 GPL 软件的衍生作品如果发布，则也必须按照 GPL 发布，而 MIT，BSD，Apache 许可证协议则较为松散，不要求衍生作品同样按照自身许可证发布，只需要恰当署名即可。介于这两种许可之间的许可有 LGPL，MPL 等。Windows 版权则归微软所有，其源代码仅小范围知晓，即使旧版 Windows 源代码已经有所泄漏，由于无法取得授权，任何看到它的人也不能合法加以利用。

尽管 Linus 宣称 Linux 内核并不是一个 portable 的内核，显然，他是目前世界上最 portable 的内核。为什么会这样呢？这跟 Linux 是自由软件有很大关系。Linus 相信，他向别人提供代码，别人也将代码分享给他，就是一种很好的模式。正因为有这种宽松自由的许可，使得 Linux 可以被任意改造去适配不同的硬件，而不需要 Linus 自己一个人或者几个人去完成这件事。

> 历史的注记：微软在 21 世纪初将 Linux 称作“癌症”，认为 Linux 侵犯了知识产权，试图在客户中培育对 Linux 的恐慌，并以专利威胁起诉 Linux 开发者。然而十年后，微软表示“We love Linux”，可能是因为 Linux 在服务器市场占有率已经很高了。

> 历史的注记：Windows 有一个臭名昭著的“功能”————蓝屏死机。这是 NT 内核在遇到不可恢复的错误时产生的错误提示信息，由于蓝色色调本身较冷，以及早期 Windows 给人以不稳定的印象，这个界面因此变得声名狼藉。然而 Linux 内核并不会出现蓝屏，一方面是 Linux 在更大程度上允许内核“带病运行”（这不一定是好事），且 Linux 的内核错误信息只显示在非图形界面的终端上，如果用户处于图形界面，只能看到大写锁定键的灯光一直闪烁，看不到任何提示信息。最近 Linux 内核开发者试图在内核严重错误时绘制一个黑色界面，并展示一个二维码作为错误提示信息。

#### 其他操作系统

- MacOS: 苹果专用，符合 POSIX 标准的 Unix 系统，老版本可在 Intel 机器安装（需要魔法），内核叫 Darwin，修改自 BSD 系内核，部分开源
- FreeBSD: 符合 POSIX 标准的类 Unix 系统，和 Linux 只是内核不同，FreeBSD 有完整的用户态程序，同时其采用更宽松的许可协议，而不是 Linux 的 GPLv2。
- DOS: 古老的操作系统，无图形界面，已不使用，微软近期开源了几个版本的 DOS。

#### 移动操作系统

- Android: Google 开发的基于 Linux 内核的操作系统，Google 自己在上面开发了 AOSP 一套环境。
- iOS: 苹果公司的产品，2007 年随 iPhone 横空问世，基于 Darwin 内核开发，封闭性较强。

## 计算机网络

我们这辈人生活在一个高度信息化的时代中，自打记事开始，很多人就知道网络，并且经常在网上进行查找资料，聊天视频，联机游戏等活动。那么计算机网络究竟是如何组织起来的呢？我们这篇文章将做一些简要的介绍

### OS/I 七层模型

```
--------------
|   应用层    |     7
--------------
|   表示层    |     6
--------------
|   会话层    |     5
--------------
|   传输层    |     4
--------------
|   网络层    |     3
--------------
|  数据链路层  |     2
--------------
|   物理层    |     1
--------------
```

目前基本不再使用 5、6 层的说法，按照 OS/I 的定义和现在的实际情况，5、6 层功能被 4、7 层包含。各层具体的作用我们以后再提。

### TCP/IP 协议

TCP 和 IP 协议分别工作在上述模型的第四层和第三层，IP 协议为世界上每一个能连入全球互联网的设备分配一个地址，同时提供不可靠的包交换服务。数据包指的是一段长度有限（但不总是固定）的数据，不可靠的包交换意思是把数据包从出发地传送到目的地，但是不保证包按照顺序到达，不保证有且仅有一个包到达，不保证包内容正确。

IP 协议目前有两个版本，一个是 IPv4，其地址由点分十进制，也就是类似于 111.111.111.111 的形式表示，每个十进制范围是 0-255，同时有许多地址被保留，如 127.xxx.xxx.xxx，10.xxx.xxx.xxx，192.168.xxx.xxx，0.0.0.0，255.255.255.255 等等，它们或被用于标示本机回环地址，或被用于局域网内，或被用于广播地址或保留地址。即使不考虑上述情况，IPv4 也只能为最多 4294967296（42 亿）个设备分配唯一地址，很明显目前地球上的人口数已经远远超过这个数值，IPv4 已经接近枯竭。目前的缓解办法包括 NAT 等协议使得多台设备共用一个公网 IP，但是这样会存在很多不方便的地方。

> 练习：114.514.1919.810 是不是有效的 IPv4 地址？

目前正在快速普及的 IPv4 的后继者是 IPv6，其地址由冒号分隔的 16 进制组成，长度是 128bit。如果地址中存在连续多项 0，可以用两个冒号替代，但是只能替代一次。下面是一些 IPv6 的地址示例：

```
::1
240c:c001:1014:4a3a:22f7:cb5f:88e2:219d
fe80::b7bf:964:d695:708d
```
IPv6 资源丰富很多，基本不会存在枯竭问题。

TCP 是在 IP 之上的协议，利用 IP 协议提供的不可靠数据传输，为上层提供流式的端到端可靠数据传输。端口号是在这一层协议定义的。TCP 协议存有状态，必须先双方三次交互建立连接，每个数据报文对方都要确认，报文都带有编号和校验码，确保报文正确按顺序到达。TCP 不能保证服务质量，比如传输速率。

> 与 TCP 同层还有 UDP 协议。UDP 协议不提供可靠传输服务，无状态，适合对数据准确性要求不高但是追求数据快速到达的场景，也适合上层实现别的可靠传输协议。

> 提示：指定端口号的地址，IPv4 可以写作 127.0.0.1:8080 这种形式，IPv6 可以写成 [::1]:8080 的形式。

### DNS 协议

DNS(Domain Name System) 协议是用于解析域名信息的协议。我们在日常上网的过程中，由于 IP 地址过于抽象难记，经常会使用类似于``` pku.edu.cn ```这样的域名，DNS 就是将域名转化为 IP 地址的服务。DNS 服务从点分隔的域名的最后一部分开始查找，整个查找过程先向系统预设的 DNS 服务器查找最后一部分``` cn ```，返回``` cn ```域名的服务器，然后向``` cn ```域名的服务器继续询问``` edu ```，直到整个域名解析完成，得到最终的 IP 地址。实际情况下，有时候 DNS 服务器会直接返回下一级域名服务器作为结果，也有时候会代替你继续查询，直接返回给你最终的结果。

> 提示：以前国内的网络运营商默认提供的 DNS 有时会遭到污染，进行植入广告等操作，这时候你可以自行更换 DNS 地址，你可以在互联网上查询到关于如何更换以及更换为哪些声誉较好的 DNS 服务的信息。
